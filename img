<%doc>

$Id$

img HTML::Mason component
Copyright (C) 2000 - 2003 Claire Connelly

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
   USA

This component generates <img> tags for images that are listed in a
file called /images.db.  It can also make those images links if the
necessary information is provided in the site's /glossary file.

In its most basic form, the component is called as

   <& /img, 'imagename' &>

which generates a basic <img> tag.

By providing additional arguments, you can specify attributes for the
tag or cause the component to generate a link around the <img> tag.
The supported arguments are

   Align        the align attribute
   Alt          the alt attribute
   Border       the border attribute
   Class        the class attribute
   Height       the height attribute
   Hspace       the hspace attribute
   Longdesc     the longdesc (long description) attribute
   URL          a URL to use as a link
   Valign       the valign attribute
   Vspace       the vspace attribute
   Width        the width attribute

The alt attribute is required -- calls to the img component without an
alt attribute will result in an error message appearing in the
rendered page.  If the image information is being read from the
images.db file, it should include the information for an alt tag.
Specifying attributes in the component call overrides any information
in the database.

Similarly, the URL argument generally comes from the glossary entry
specified using the Gloss argument, as in

   <& /img, 'image', Gloss=>'glossary' &>



Format of image.db File

The image.db file is read in and evaluated as a Perl hash-of-hashes.
It must begin and end with parentheses.  Each entry key points to a
hash containing, at minimum, the complete filename of the image (not
including the path, which is assumed to be /images) and an appropriate
alt text describing the image.  Each entry is delimited by commas.  A
minimal image.db file might be

   (
      "foo" => {
	 Filename => "foo.png",
	 Alt      => "foos in love",
      },
   )

Called with

   <& /img, 'foo' &>

in a top-level page and assuming that the foo.png image was 50 pixels
by 75 pixels, the component would produce an <img> tag such as

   <img src="images/foo.png" height="50" width="75" alt="foos in love" />


The img component was inspired by the img command in Userland Frontier
and my modifications to it and to the glossSub command.

</%doc>

% if ( defined $image{URL} ) {
<a href="<% $image{URL} %>">\
% }
<img src="<% $image{Filename} %>"\
% if (defined $image{Class} ) {
 class="<% $image{Class} %>"\
% }
% if ( defined $image{Height} ) {
 height="<% $image{Height} %>"\
% }
% if ( defined $image{Width} ) {
 width="<% $image{Width} %>"\
% }
% if (defined $image{Align} ) {
 align="<% $image{Align} %>"\
% }
% if (defined $image{Valign} ) {
 valign="<% $image{Valign} %>"\
% }
% if (defined $image{Hspace} ) {
 hspace="<% $image{Hspace} %>"\
% }
% if (defined $image{Vspace} ) {
 vspace="<% $image{Vspace} %>"\
% }
% if (defined $image{Border} ) {
 border="<% $image{Border} %>"\
% }
% if (defined $image{Longdesc} ) {
 longdesc="<% $image{Longdesc} %>"\
% }
% if (defined $image{Title} ) {
 title="<% $image{Title} %>"\
% }
%# The alt attribute is required
 alt="<% $image{Alt} %>"\
%# Close the img tag (make it XML-compliant)
 />\
% if ( defined $image{URL} ) {
</a>\
% }
% if ( $debug ) {
<p><code>
siteroot = <% $siteroot %><br />
imageroot = <% $imageroot %><br />
pageuri = <% $pageuri %><br />
imagepath = <% $imagepath %><br />
imagelinkbase = <% $imagelinkbase %><br />
image{Filename} = <% $image{Filename} %><br />
image{Width} = <% $image{Width} %><br />
image{Height} = <% $image{Height} %><br />
image{Alt} = <% $image{Alt} %><br />
image{Text} = <% $image{Text} %><br />
image{TmpAlt} = <% $image{TmpAlt} %><br />
 
% foreach my $foo (sort keys (%image)) {
<% $foo %>=><% $image{$foo} %><br />
% }
</code></p>
% } # End of debug if
<%init>
### Output debugging information?
my $debug = 3;

### Import some information from the current page.
our ($webhostname, $pageuri, $siteroot, $imageroot, $imagedir, $imagelinkbase);

## Name of image database files.
my $IMAGEDB = "images.yaml";

### Set up some default values for the image hash we will be using
### to generate our output.
my %image = (
	     Filename => "/dev/null",
#	     Alt      => "[mystery image]",
	     Border   => 0,
	    );


my $imagepath;

### Import the image database.

## Old-skool -- we expect the database file to be Perl code and eval
## it.
#  my %imagedb = eval ( $m->scomp('image.db') );

### New school: Look through the directory hierarchy for appropriate
### image databases.

## Hashref for master image database.
our $imagedb;

## Figure out the directory path for our calling component.
my $dirpath = $m->request_comp->dir_path;

## Cache results to allow reuse of calculated database if called
## within a short period of time since the previous call.

our $CACHE_TIME = 5;		# Set to 5 seconds.

## Set some variables we can check for the lifetime of this page's
## processing.
our $requesttime;
our $lastdirpath;
our $lastrequesttime;

print "Last request at $lastrequesttime <br />\n" if (defined $lastrequesttime and $debug >= 1);
print "This request at $requesttime <br />\n" if $debug >= 1;

## Load the image database files.  Note that we only run this
## routine if we
# if ( ! defined $lastdirpath	# Have never run
#     or $lastdirpath ne $dirpath	# Are starting from a different location
#     or $lastrequesttime + $CACHE_TIME < $requesttime ) # Cache hasn't expired
#   {
#     $lastdirpath = $dirpath;
#     $lastrequesttime = $requesttime;
    print "\n<br />Loading $IMAGEDB for $dirpath\n<br />\n" if $debug >= 1;

    print "REQ: ", $m->request_comp->dir_path, "\n<br />" if $debug;


    ### Identify glossaries to load.

    ## Get a list of directories to look through.
    my @dirs = split ('/', $m->request_comp->dir_path );
    push @dirs, '' unless @dirs;

    print "\@dirs = (", join(", ", @dirs), ")\n<br />" if ( $debug >= 1 );

    ## Assemble a list of available image databases in the hierarchy.
    my @image_dbs;

    while (@dirs) {
	## Assemble a full path from the list of directories to scan.
	my $path = join('/', @dirs );
	print "\$path is $path\n" if ( $debug >= 1 );

	## Check to see if an image database exists for that path.
	my $idbtest = "$path/$IMAGEDB";
	print "\n<br/> checking '$idbtest'<br/>" if ( $debug >= 2 );

	## If we find a database, add it to the list.
	if ( $m->comp_exists($idbtest) ) {
	    print " -- found!" if ( $debug >= 2 );
	    push ( @image_dbs, $idbtest );
	}
	## Throw away the last directory component.
	pop @dirs;
    }

    print "\n<br />\n\@image_dbs = (", join(", ", @image_dbs), ")<br />\n" if ( $debug >= 1 );


    ### Load the contents of the found image database.

    ## Start from the top of the directory tree (the most general)
    ## and moving down through the tree to the image database
    ## closest to the requesting page.  This method gives us the
    ## equivalent of ``cascading image databases'' -- entries in
    ## image databases closer to a requesting object can override
    ## those from higher up, thus allowing the same image keys to be
    ## defined differently for different parts of a site.

    while ( @image_dbs ) {
	my $imagedbpath = pop @image_dbs;
	print "<br />loading $imagedb<br />\n" if ( $debug >= 1 );

	# Slurp in the contents of the image database file as a
	# string.
	my $imagedata = $m->scomp($imagedbpath);

	# Skip this one if the file is empty.
	next if ( $imagedata =~ m/^\s*\z/ );

        # Construct a hash from the data in the string.
        $imagedb = YAML::Load ( $imagedata );
    }

# } else {
#     print "\n<br />Reusing loaded image database for $dirpath\n<br />\n" if $debug >= 1;
# }

### Deal with the image we're being called on.

### Parse component arguments.
my @arguments = @_;

## The first argument is the name of the image
my $imagename = shift @arguments;

## Any other arguments should be parameters -- we'll merge them into
## our %image hash.
my $imagedb_entry = $imagedb->{$imagename};

if ( defined $imagedb_entry ) {
  %image = (%image, %$imagedb_entry, @arguments);
  my $imagefile = $image{Filename};
  $image{Filename} = $imagelinkbase . $imagefile;

# We need the $imagepath on the local file system to be able to get
# the dimensions of the image
  $imagepath = "$imagedir/images/" . $imagefile;
  my ( $width, $height ) = ( Image::Size::imgsize($imagepath) );
  $image{Width} = $width unless defined $image{Width};
  $image{Height} = $height unless defined $image{Height};

 if ( defined $image{Gloss}) {
   # If we have a Gloss parameter, we should look to see if there's a
   # glossary entry
   my $glossentry = $image{Gloss};
   my %glossary = eval ( $m->file('glossary') );
   my $glossary_entry = $glossary{$glossentry};

   if ( defined $glossary_entry ) {
     %image = ( %image, %$glossary_entry );
     if ( ! defined $image{Alt} ) {
       $image{Alt} = $image{Text};
     }
  }
}

  if ( ( ! defined $image{Alt} ) || ( $image{Alt} eq "" ) ) {
    $image{Alt} = "[mystery image]";
    } 

if ( ! defined $image{Title} ) {
   $image{Title} = $image{Alt};
}

  if ( defined $image{ORURL} ) {
    $image{URL} = $image{ORURL};
  } elsif ( ( defined $image{URL} ) && ( $image{URL} !~ m/^http:/ ) ) {
    $image{URL} = $image{URL};
    my $linkuri = URI->new_abs($image{URL}, $siteroot);
    $image{URL} = $linkuri->rel($pageuri);
  }
} else {
  print "<p class=\"error\">No such image, $imagename.</p>\n";
}
</%init>
