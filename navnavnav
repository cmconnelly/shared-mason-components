<%doc>

$Id: uparrowp 204 2003-10-30 20:58:07Z cmc $

navnavnav HTML::Mason Navigation Component
Copyright (C) 2007 Claire Connelly

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
   USA


Usage

The component is called as

      <& /navnavnav &>

You will generally want to enclose it in a <div></div> pair to aide
in CSS styling.

The result is an unordered list (<ul>) containing list items (<li>)
with links correspponding to the links specified in navigation hint
files in each directory.  Links for subdirectories are enclosed
within the <li> corresponding to the link that corresponds to the
enclosing directory.  Those links are given the CSS class section,
which can be used for adjusting appearance via CSS.

List items corresponding to the calling page do not include links;
instead they are labelled with the CSS class thispagelink, which can
be used to adjust its appearance to fit in with or stand out from
the surrounding links.


Arguments

Without any arguments, the result will not include links from the
top level of the site.  Combined with the use of the argument "main"
in a separate component call, as in

   <& /navnavnav, 'main' &>

you can easily generate sitewide and sectional navigation from the
same navigation hints.

With the main argument, this component will only examine (and
produce links for) the navigation file at the top of the hierarchy.

By adding the argument "full" to the component call, as in

   <& /navnavnav, 'full' &>

this component will generate menus that include the top-most level.


TODO

It would probably be good to tag the opening and closing list items
in some way, to aid styling with CSS.

</%doc>
%# ------------------------------------------------------------
% print_menus ($navinfo);
%# ------------------------------------------------------------
<%init>
use Data::Dumper;
our $debug = 0;

### Grab any arguments we may have been passed for later processing.
my ( $main_nav ) = shift;

if ( $debug ) {
  print "<p><code>\$main_nav was $main_nav</code></p>\n";
}

### Grab some information about our working environment.
our ($webhostname, $pageuri, $siteroot, $requri, $pagesect, $sitebase);
our $requesttime;
our $lastdirpath;
our $lastrequesttime;

### Figure out the directory path to the page being rendered.
my $dirpath;
if ( $main_nav =~ m{main}i ) {
  ## Master navigation block; only use navigation from the top of
  ## the hierarchy.
  $dirpath = "/";
} else {
  $dirpath   = $m->request_comp->dir_path;
}
print "<code>\$dirpath is $dirpath</code><br/>\n" if ( $debug );

my $path   = $m->request_comp->path;
print "<code>\$path is $path</code><br/>\n" if ( $debug );


### Navigation hints file.
my $navsrc = "navigation";

### Get a list of directories to search for navigation files.

# Turn something like "/clinic/projects" into ("", "clinic", "projects").
my @dirs = split "/", $dirpath;

my $navinfo;   # A reference to a hash with the combined nav data.
               # "Build from the bottom up, not the top down" -- FDR.
my $lastlevel; # The name of the most recent level we processed.

### Go through each of the dirs and look for a navigation file; that
### is, look for "/clinic/projects/navigation",
### "/clinic/navigation", "/navigation" (in that order).  Once we
### start finding navigation files, we build up our hierarchy of
### navigation elements in $navinfo.

### Add a space to the end of the array in case it's empty (we're at
### the root of the file system tree).  Later we'll make that space
### into a proper path.
push @dirs, " ";

### Data-gathering loop.
while ( @dirs ) {
    ## Assemble the working path for each directory in the hierarchy.
    my $workingpath = join ( '/', @dirs );
    $workingpath = "/" if ( $workingpath eq " " );

    ## Add the navigation source filename to the path.
    my $navfile = "$workingpath/$navsrc";
    if ( $debug > 5 ) {
      print "<p><code>\$navfile = $navfile</code></p>\n";
    }

    unless ( $m->comp_exists ($navfile) ) {
	## No navigation file; that's okay out at the leaves, but not
	## okay after we find our first navigation file.
	if ( defined $navinfo ) {
	    warn "Missing file $navfile;  may do wrong thing, who knows";
	}
	next;
    }

    ### Now we have a navigation file to work with.

    ## Suck in the contents of the file.
    my $navdata = $m->scomp($navfile);
    unless ( defined $navdata ) {
       warn "Couldn't load navdata file $navfile";
       next;
    }

    ## Parse the file contents into a data structure using the YAML
    ## module.
    my $thislevel = YAML::Load ( $navdata );
    unless ( defined $thislevel ) {
       warn "Couldn't load YAML data for $navfile";
       next;
    }

    if ( $debug >= 3 ) {
      print "<pre style=\"clear: both;\">\n";
      print Dumper ( $navinfo );
      print "\n</pre>\n";
    }

    ## Substitute a complete path for each navigational item.
    foreach my $key ( keys %{ $thislevel } ) {
      $thislevel->{$key}{Path} = $workingpath . '/' . $thislevel->{$key}{Path};
    }

    if (defined $navinfo) {
    	## This run is not the first run; that is, we already have
    	## data from somewhere deeper in the hierarchy.  For
    	## example, we just processed "/clinic/projects/navigation"
    	## and now we're processing "/clinic/navigation".
        unless ( defined $thislevel->{$lastlevel} ) {
            warn "Expected to find an entry for $lastlevel in $navfile";
        }
        $thislevel->{$lastlevel}{Submenu} = $navinfo;
        $navinfo = $thislevel;
    } else {
        # This is the first time through, there is no preexisting navinfo to
        # to link in
        $navinfo = $thislevel;
    }
    # Move up the hierarchy, but remember where we just were
    } continue {
      $lastlevel = pop @dirs; 
}



### Print out the entire data structure for the navigation hash.
if ( $debug > 3 ) {
  print "<pre style=\"clear: both;\">\n";
  print Dumper ( $navinfo );
  print "\n</pre>\n";
}


### Define the routine for generating menus as a recursive function.
sub print_menus ($);
sub print_menus ($) {
  print "<ul>\n";
  my ( $navElems ) = @_;  # A hash containing named navigational elements.

  unless (ref $navElems eq 'HASH') {
    print "<pre>Passed ``$navElems'', not a hash ref</pre>";
    return;
  }

  ## We want the menus to appear in the order in which they were
  ## defined to appear rather than in alphabetical order by key
  ## (directory name), as that key may or may not correspond to the
  ## ordering of the page titles or to any specific ordering that
  ## the site maintainers might desire.

  ## Ideally, we would keep the order the same as the order defined
  ## by appearance in the navigation source files.  In the meantime,
  ## as a bit of a hack, we specify an Order field in the navigation
  ## files, and sort on that field here.
  my @order = sort {
    $navElems->{$a}{Order} <=> $navElems->{$b}{Order}
      or $navElems->{$a}{Title} cmp $navElems->{$b}{Title} }
    ( keys %$navElems );   # FIXME!  Arbitrary order!!!

  if ( $debug > 5 ) {
      print "<p><code>\@order = " . ( join ", ", @order ) . "</code></p>\n";
  }

  ### Now we use the ordered list to generate list items.
  foreach my $key ( @order ) {
    my $navElem = $navElems->{$key};

    ## Full path to the menu item.
    my $navpath =  "/" . $sitebase . $navElem->{Path};

    ## Clean up any doubled slashes.
    $navpath    =~ s|//|/|g;

    ## Calculate a full and relative URI for the item.
    my $linkuri     = URI->new_abs($navpath, $siteroot);
    my $reluri      = $linkuri->rel($pageuri);

    ## Calculate a URL to the item's section.
    my $linksecturi = $linkuri;
    $linksecturi    =~ s|(http://.*/).*\.html$|$1|;

    ## Chop off any html file to get a URI for the page.
    $pageuri        =~ s|(http://.*/).*\.html$|$1|;

    ## Check to see if the link we're creating contains the current page.
    my $li_classes;
    if ( $pageuri =~ m/$linksecturi/ ) {
	$li_classes = "section";
    }



   if ( $debug > 3 ) {
     print "<code>\$requri:   $requri</code><br/>\n";
     print "<code>\$navpath:     $navpath</code><br/>\n";
     print "<code>\$siteroot:    $siteroot</code><br/>\n";
     print "<code>\$pageuri:     $pageuri</code><br/>\n";
     print "<code>\$linkuri:     $linkuri</code><br/>\n";
     print "<code>\$reluri:      $reluri</code><br/>\n";
     print "<code>\$pagesect:    $pagesect</code><br/>\n";
     print "<code>\$linksecturi: $linksecturi</code><br/>\n";

     print "<br/>";
     print "<code>Title: $navElem->{Title}</code><br/>\n";
     print "<code>Path:  $navElem->{Path}</code><br/>\n";
     print "<code>Order: $navElem->{Order}</code><br/>\n";
     print "<code>Submenu: $navElem->{Submenu}</code><br/>\n";
   }

    ### Only include the top level of links if requested.
#    if ( ! $main_nav =~ m{full}i ) {
	if ( $navElem->{Path} =~ m{^/\w+/$} ) {
	    next unless ( $navElem->{Submenu} );
	}
#    }

    # Actually create the list item and link.
    print "<li";

    # Don't create links for the current page.
    if ( URI::eq ( $pageuri, $linkuri ) ) {
	$li_classes = "thispagelink";
    }

    # Add any defined classes.
    if ( $li_classes ) {
	print " class=\"$li_classes\"";
    }

    # Close the opening <li> tag.
    print ">";

    ## Create links for menu items that don't point to the current
    ## page.
    if ( ! URI::eq ( $pageuri, $linkuri ) ) {
      print "<a href=\"$reluri\">";
    }

    # Print the content of the list item/link.
    print "$navElem->{Title}";

    ## Close the link, if we're creating one.
    if ( ! URI::eq ( $pageuri, $linkuri ) ) {
	print "</a>";
    }

    ## Before we add the closing </li> tag, check for the existence
    ## of a submenu; if there is one, recursively call this routine
    ## to fill in that information.
    my $submenu = $navElem->{Submenu};
    if ( defined $submenu ) {
      print "\n";
      print_menus $submenu;
    }

    ## Now close the </li> tag.
    print "</li>\n";
  }
  print "</ul>\n";
}



</%init>
